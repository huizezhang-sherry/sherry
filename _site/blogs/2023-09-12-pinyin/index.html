<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="H. Sherry Zhang">
<meta name="dcterms.date" content="2023-09-12">
<meta name="description" content="It is likely that you may need to interact with colleagues or students from China, for whom you will need to pronounce their names, even if it is just the surname.">

<title>H. Sherry Zhang - Pinyin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../avatar.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">H. Sherry Zhang</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blogs/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/huizezhang-sherry"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header">
<h1 class="title display-7">Pinyin</h1>
<p class="author">H. Sherry Zhang</p>

<p class="date">2023-09-12</p>
</header>


<p>No one wants to correct others. However, it is likely that you may need to interact with colleagues or students from China, for whom you will need to pronounce their names, even if it is just the surname. This post is not aiming to provide a comprehensive or official explanation of the Pinyin system, but a 5 mins quick guide on how the system functions and helps you with pronouncing one or two characters well enough to impress your colleagues/ students. Of course, we will not delve into tone, which is another 50 hours of work to master. It is worth noting that we will focus on the Pinyin system used in mainland China and the system used in other regions, such as Hong Kong, Taiwan, and Macau, may have slight variations. You may recognise the same word is represented differently, for example, the surname Âº†, is <strong>Zhang</strong> in Pinyin but <em>Chang</em> in the Wade‚ÄìGiles (WG) system.</p>
<section id="how-pinyin-is-used-to-represent-words" class="level2">
<h2 class="anchored" data-anchor-id="how-pinyin-is-used-to-represent-words">How Pinyin is used to represent words</h2>
<p>Chinese differs from English that it doesn‚Äôt concatenate alphabets into words. Instead, there is a fixed set of consonant sounds (also called <em>initials</em>) and another set of vowel sounds (also called <em>finals</em>), which are combined into a finite set of pronunciations for all the Chinese characters. To encode all the possible characters into this set of pronunciations using Pinyin, you can expect different characters to share the same Pinyin and have the same sound. For example, the following three characters all have the Pinyin <strong>f√°</strong>: ÁΩö-punishÔºå‰ºê-logging (a tree)Ôºå‰πè-tired.</p>
</section>
<section id="given-name-split" class="level2">
<h2 class="anchored" data-anchor-id="given-name-split">Given name split</h2>
<p>Unlike English ones, a Chinese given name usually consists of two characters. We don‚Äôt have the concept of a middle name, and it is not standard to treat the second character in the given name as the middle name. Hence, the two characters are often combined into a single word in the given name. <u>Recognising where to split the given name increases your chance of sounding correct. </u> For example, you can try my name <strong>Zhang Huize</strong> (Âº†ÊÖßÊ≥Ω) and again if you know it should be split into <strong>Zhang Hui Ze</strong>. This split is usually obvious since a single character in Pinyin comprises a consonant and a vowel (with limited cases of no consonant) and the consonant and the vowels set do not overlap:</p>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Pinyin</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Consonants</td>
<td>b, p, m, f, d, t, n, l, g, k, h, j, q, x, z, c, s, zh, ch, sh, r, y, w</td>
</tr>
<tr class="even">
<td>Vowels</td>
<td>a, o, e, i, u, √º, <br> ai, ei, ui, ao, ou, iu, ie, √ºe, er, an, en, in, un, ang, eng, ing, ong <br> ia, iao, ian, iang, iong, ua, uo, uai, uang</td>
</tr>
</tbody>
</table>
<p>All the vowels start with an English vowel (a,e,i,o,u) and end with another vowel, or an ‚Äún‚Äù, or a ‚Äúg‚Äù. Here are more examples of the split:</p>
<ul>
<li><strong>Su Buqing</strong> - <strong>Su Bu Qing</strong> | <a href="https://en.wikipedia.org/wiki/Su_Buqing">ËãèÊ≠•Èùí</a> (1902-2003) mathematician, served as the president of Fudan University,</li>
<li><strong>Wu Jianxiong</strong> - <strong>Wu Jian Xiong</strong> (also <em>Wu Chien-Shiung</em> in the WG system) | <a href="https://en.wikipedia.org/wiki/Chien-Shiung_Wu">Âê¥ÂÅ•ÈõÑ</a> (1912-1997) particle and experimental physicist, the Wu experiment resulted in her colleagues winning the 1957 Nobel Prize in Physics, and</li>
<li><strong>Zhang Ailing</strong> - <strong>Zhang Ai Ling</strong> (also <em>Chang Ai-ling</em> in the WG system) | <a href="https://en.wikipedia.org/wiki/Eileen_Chang">Âº†Áà±ÈìÉ</a> (1920-1995) writer, notable work: <a href="https://en.wikipedia.org/wiki/Love_in_a_Fallen_City_(novella)">Love in a fallen city</a>.</li>
</ul>
</section>
<section id="now-lets-talk-about-pronunciation" class="level2">
<h2 class="anchored" data-anchor-id="now-lets-talk-about-pronunciation">Now let‚Äôs talk about pronunciation</h2>
<p>If you read Pinyin as if it were English, it is likely that you have already got many under the belt, e.g.&nbsp;bai (as ‚Äúbye‚Äù) and tan (similar to ‚Äútangent‚Äù but without the ‚Äúgent‚Äù). Here, we will highlight the most commonly mispronounced consonants and vowels, and you can find the audio for all the combinations on <a href="https://chinese.yabla.com/chinese-pinyin-chart.php">this website</a>.</p>
<section id="consonants" class="level3">
<h3 class="anchored" data-anchor-id="consonants">Consonants</h3>
<ul>
<li><strong>zh, ch, sh</strong>: <u>The letter <strong>h</strong> is not silent in pinyin! </u> Unlike the versions without h (<strong>z, c, s</strong>), where you upper teeth almost touch the lower ones, for <strong>zh, ch,</strong> and <strong>sh</strong>, you will form your lips in to a ‚Äúless than‚Äù (&lt;) shape. This will produce a sound similar to the ‚Äúj‚Äù in English for <strong>zh</strong>, the ‚Äúch‚Äù sound in ‚Äúcheese‚Äù for <strong>ch</strong>, and the ‚Äúsh‚Äù sound in ‚Äúshape‚Äù for <strong>sh</strong>. The Pinyin <strong>j</strong> sounds like ‚ÄúJeep‚Äù without the p sound.</li>
<li><strong>q, x</strong>: <u>These are the two hardest, and essentially, there is no equivalence in English</u>. The International Phonetic alphabet (IPA) that provides the guidance on the mouth position for pronouncing these sounds. But if you only have 5 minutes to master the pronunciation, the most efficient way would likely to be listening to the audio of the specific sound multiple times: <a href="https://chinese.yabla.com/chinese-pinyin-chart.php" class="uri">https://chinese.yabla.com/chinese-pinyin-chart.php</a></li>
</ul>
</section>
<section id="vowels" class="level3">
<h3 class="anchored" data-anchor-id="vowels">Vowels</h3>
<ul>
<li><strong>ang, eng, ing, ong</strong>: <u>The letter <strong>g</strong> is also not silent in pinyin!</u> Distinguishing between <strong>eng/ing/ong</strong> might be less crucial since ‚Äúon‚Äù is not a recognised vowel and some native speakers (I‚Äôm looking at you shanghainese) may struggle to differentiate between the en/eng and in/ing combinations. The <strong>ang</strong>, and its version without g, <strong>an</strong>, sound completely different: <u><strong>ang</strong> sounds like ‚Äúon‚Äù in English and <strong>an</strong> sounds more like the ‚Äúan‚Äù part in ‚Äúanswer‚Äù. </u></li>
<li><strong>ia, iao, ian, iang, iong, ua, uo, uai, uang</strong>: Think of this category as blending the <strong>i/u</strong> sound (<strong>i</strong> as in ‚Äúee‚Äù and <strong>u</strong> as in ‚Äúw‚Äù) into the next vowel. For example, <strong>ia</strong> as in ‚Äúvia‚Äù and <strong>uai</strong> as in ‚Äúwhite‚Äù without the t sound.</li>
</ul>
</section>
</section>
<section id="your-turn" class="level2">
<h2 class="anchored" data-anchor-id="your-turn">Your turn</h2>
<p>Here we have the most common 10 surnames for you to try out:</p>
<blockquote class="blockquote">
<p>Wang, Li, Zhang, Liu, Chen, Yang, Zhao, Huang, Zhao, Wu, Zhou</p>
</blockquote>
<p>and a platter of given names:</p>
<blockquote class="blockquote">
<p>Chao, Guo, Han, Hao, Hong, Hua, Jia, Jie, Jing, Jun, Lan, Lei, Ming, Ping, Shi, Ting, Wei, Xin, Xuan, Yan, Yi, Ying, Yu, Zi</p>
</blockquote>
<p>Listen <a href="https://chinese.yabla.com/chinese-pinyin-chart.php">here</a> if you are not sure about anyone.</p>
<p>One trivia on Chinese names is that the most common name in China is <em>Zhang Wei, Âº†‰ºü,</em> which is shared over 3 million people! ü§Ø</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/huizezhangsh\.netlify\.app\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>